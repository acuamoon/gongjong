<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <title>Red Zone</title>
    <style>
        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 80%;  /* 5:4 비율 */
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="nav-placeholder"></div>
    <script>
        fetch('nav.html')
          .then(response => response.text())
          .then(data => {
              document.getElementById('nav-placeholder').innerHTML = data;
          });
    </script>
    <div class="container-fluid">
        <div class="row justify-content-center">
            <div class="col text-center mt-2 mb-2">
                <h2 class="text-primary fw-bold">Red Zone Detection</h2>
                <p class="text-secondary">감지하고자 하는 부분으로 카메라를 조정하세요</p>
                <button id="drawButton" class="btn btn-primary mb-2">박스 그리기</button>
                <button id="clearButton" class="btn btn-secondary mb-2">지우기</button>
            </div>
        </div>
        <div class="video-container">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        <!-- 싸이렌 소리 추가 -->
        <audio id="siren" src="siren.mp3" preload="auto"></audio>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const siren = document.getElementById('siren');
        const drawButton = document.getElementById('drawButton');
        const clearButton = document.getElementById('clearButton');

        let isDrawing = false;
        let startX, startY;
        let userBox = null;

        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
            .then(function (stream) {
                video.srcObject = stream;
            });

        function adjustCanvasSize() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }

        video.addEventListener('loadeddata', adjustCanvasSize);
        window.addEventListener('resize', adjustCanvasSize);

        drawButton.addEventListener('click', () => {
            isDrawing = true;
            drawButton.disabled = true;
        });

        clearButton.addEventListener('click', () => {
            userBox = null;
            drawButton.disabled = false;
        });

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', endDrawing);

        function startDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            startX = (e.clientX || e.touches[0].clientX) - rect.left;
            startY = (e.clientY || e.touches[0].clientY) - rect.top;
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const endX = (e.clientX || e.touches[0].clientX) - rect.left;
            const endY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            userBox = [startX, startY, endX - startX, endY - startY];
        }

        function endDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            drawButton.disabled = false;
        }

        function drawDangerZone() {
            if (userBox) {
                context.beginPath();
                context.rect(...userBox);
                context.strokeStyle = 'red';
                context.lineWidth = 2;
                context.stroke();

                context.fillStyle = 'rgba(255, 0, 0, 0.3)';
                context.fill();

                // 위험지역 라벨 추가
                context.font = '24px Arial';
                context.fillStyle = 'red';
                context.fillText('위험지역', userBox[0], userBox[1] - 10);
            }
        }

        cocoSsd.load().then(model => {
            predict();
            function predict() {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                model.detect(canvas).then(predictions => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    drawDangerZone();

                    let personDetected = false;
                    predictions.forEach(prediction => {
                        if (prediction.class === 'person' && userBox) {
                            const [x, y, width, height] = prediction.bbox;
                            const [ux, uy, uwidth, uheight] = userBox;
                            
                            // 박스 간 겹침 확인
                            if (x < ux + uwidth &&
                                x + width > ux &&
                                y < uy + uheight &&
                                y + height > uy) {
                                personDetected = true;
                                context.fillStyle = 'rgba(255, 0, 0, 0.3)';
                                context.fillRect(...prediction.bbox);
                            }
                        }

                        context.beginPath();
                        context.lineWidth = 2;
                        context.strokeStyle = prediction.class === 'person' ? 'red' : 'blue';
                        context.rect(...prediction.bbox);
                        context.stroke();

                        // 텍스트 설정
                        context.font = '32px Arial';
                        var text = prediction.class + ' ' + parseInt(prediction.score * 100) + '%';
                        var x = prediction.bbox[0];
                        var y = prediction.bbox[1];

                        var textWidth = context.measureText(text).width;
                        var textHeight = parseInt(context.font, 10);

                        context.fillStyle = context.strokeStyle;
                        context.fillRect(x, y - textHeight, textWidth, textHeight);

                        context.fillStyle = 'white';
                        context.fillText(text, x, y);
                    });

                    if (personDetected) {
                        siren.play();
                    } else {
                        siren.pause();
                        siren.currentTime = 0;
                    }
                });
                requestAnimationFrame(predict);
            }
        });           
    </script>
</body>
</html>