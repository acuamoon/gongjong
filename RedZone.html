<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <title>Red Zone</title>
    <style>
        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 80%;  /* 5:4 비율 */
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="nav-placeholder"></div>
    <script>
        fetch('nav.html')
          .then(response => response.text())
          .then(data => {
              document.getElementById('nav-placeholder').innerHTML = data;
          });
    </script>
    <div class="container-fluid">
        <div class="row justify-content-center">
            <div class="col text-center mt-2 mb-2">
                <h2 class="text-primary fw-bold">Red Zone Detection</h2>
                <p class="text-secondary">감지하고자 하는 부분으로 카메라를 조정하세요</p>
                <button id="drawButton" class="btn btn-primary mb-2">영역 그리기</button>
            </div>
        </div>
        <div class="row mt-3">
            <div class="col">
                <div class="input-group mb-3">
                    <span class="input-group-text">X1</span>
                    <input type="number" class="form-control" id="boxX1">
                    <span class="input-group-text">Y1</span>
                    <input type="number" class="form-control" id="boxY1">
                    <span class="input-group-text">X2</span>
                    <input type="number" class="form-control" id="boxX2">
                    <span class="input-group-text">Y2</span>
                    <input type="number" class="form-control" id="boxY2">
                </div>
            </div>
        </div>
        <div class="video-container">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        <!-- 싸이렌 소리 추가 -->
        <audio id="siren" src="siren.mp3" preload="auto"></audio>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const siren = document.getElementById('siren');
        const drawButton = document.getElementById('drawButton');
        const boxX1 = document.getElementById('boxX1');
        const boxY1 = document.getElementById('boxY1');
        const boxX2 = document.getElementById('boxX2');
        const boxY2 = document.getElementById('boxY2');

        let isDrawing = false;
        let clickCount = 0;
        let userBox = null;

        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
            .then(function (stream) {
                video.srcObject = stream;
            });

        function adjustCanvasSize() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }

        video.addEventListener('loadeddata', adjustCanvasSize);
        window.addEventListener('resize', adjustCanvasSize);

        drawButton.addEventListener('click', () => {
            isDrawing = true;
            clickCount = 0;
            drawButton.disabled = true;
        });

        canvas.addEventListener('click', (e) => {
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (clickCount === 0) {
                    userBox = [x, y, x, y];
                    clickCount++;
                } else if (clickCount === 1) {
                    userBox[2] = x;
                    userBox[3] = y;
                    isDrawing = false;
                    drawButton.disabled = false;
                    updateInputFields();
                }
            }
        });

        function updateInputFields() {
            if (userBox) {
                boxX1.value = Math.round(userBox[0]);
                boxY1.value = Math.round(userBox[1]);
                boxX2.value = Math.round(userBox[2]);
                boxY2.value = Math.round(userBox[3]);
            }
        }

        [boxX1, boxY1, boxX2, boxY2].forEach(input => {
            input.addEventListener('change', () => {
                userBox = [
                    parseFloat(boxX1.value) || 0,
                    parseFloat(boxY1.value) || 0,
                    parseFloat(boxX2.value) || 0,
                    parseFloat(boxY2.value) || 0
                ];
            });
        });

        function drawDangerZone() {
            if (userBox) {
                context.beginPath();
                context.rect(
                    Math.min(userBox[0], userBox[2]),
                    Math.min(userBox[1], userBox[3]),
                    Math.abs(userBox[2] - userBox[0]),
                    Math.abs(userBox[3] - userBox[1])
                );
                context.strokeStyle = 'red';
                context.lineWidth = 2;
                context.stroke();

                context.fillStyle = 'rgba(255, 0, 0, 0.3)';
                context.fill();

                // 위험지역 라벨 추가
                context.font = '24px Arial';
                context.fillStyle = 'red';
                context.fillText('위험지역', Math.min(userBox[0], userBox[2]), Math.min(userBox[1], userBox[3]) - 10);
            }
        }

        cocoSsd.load().then(model => {
            predict();
            function predict() {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                model.detect(canvas).then(predictions => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    drawDangerZone();

                    let personDetected = false;
                    predictions.forEach(prediction => {
                        if (prediction.class === 'person' && userBox) {
                            const [x, y, width, height] = prediction.bbox;
                            const [ux1, uy1, ux2, uy2] = userBox;
                            const ux = Math.min(ux1, ux2);
                            const uy = Math.min(uy1, uy2);
                            const uwidth = Math.abs(ux2 - ux1);
                            const uheight = Math.abs(uy2 - uy1);
                            
                            // 박스 간 겹침 확인
                            if (x < ux + uwidth &&
                                x + width > ux &&
                                y < uy + uheight &&
                                y + height > uy) {
                                personDetected = true;
                                context.fillStyle = 'rgba(255, 0, 0, 0.3)';
                                context.fillRect(...prediction.bbox);
                            }
                        }

                        context.beginPath();
                        context.lineWidth = 2;
                        context.strokeStyle = prediction.class === 'person' ? 'red' : 'blue';
                        context.rect(...prediction.bbox);
                        context.stroke();

                        // 텍스트 설정
                        context.font = '32px Arial';
                        var text = prediction.class + ' ' + parseInt(prediction.score * 100) + '%';
                        var x = prediction.bbox[0];
                        var y = prediction.bbox[1];

                        var textWidth = context.measureText(text).width;
                        var textHeight = parseInt(context.font, 10);

                        context.fillStyle = context.strokeStyle;
                        context.fillRect(x, y - textHeight, textWidth, textHeight);

                        context.fillStyle = 'white';
                        context.fillText(text, x, y);
                    });

                    if (personDetected) {
                        siren.play();
                    } else {
                        siren.pause();
                        siren.currentTime = 0;
                    }
                });
                requestAnimationFrame(predict);
            }
        });           
    </script>
</body>
</html>